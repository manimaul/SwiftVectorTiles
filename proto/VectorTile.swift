// Generated by the Protocol Buffers 3.0 compiler.  DO NOT EDIT!
// Source file "vector_tile.proto"
// Syntax "Proto2"

import Foundation
import ProtocolBuffers


public struct VectorTile { }

public extension VectorTile {
  public struct VectorTileRoot {
    public static let `default` = VectorTileRoot()
    public var extensionRegistry:ExtensionRegistry

    init() {
      extensionRegistry = ExtensionRegistry()
      registerAllExtensions(registry: extensionRegistry)
    }
    public func registerAllExtensions(registry: ExtensionRegistry) {
    }
  }

  final public class Tile : ExtendableMessage {

    public static func == (lhs: VectorTile.Tile, rhs: VectorTile.Tile) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.layers == rhs.layers)
      fieldCheck = fieldCheck && lhs.isEqualExtensionsInOther(otherMessage: rhs, startInclusive:16, endExclusive:8192)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }



    //Nested type declaration start

      // Variant type encoding
      // The use of values is described in section 4.1 of the specification
      final public class Value : ExtendableMessage {

        public static func == (lhs: VectorTile.Tile.Value, rhs: VectorTile.Tile.Value) -> Bool {
          if (lhs === rhs) {
            return true
          }
          var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
          fieldCheck = fieldCheck && (lhs.hasStringValue == rhs.hasStringValue) && (!lhs.hasStringValue || lhs.stringValue == rhs.stringValue)
          fieldCheck = fieldCheck && (lhs.hasFloatValue == rhs.hasFloatValue) && (!lhs.hasFloatValue || lhs.floatValue == rhs.floatValue)
          fieldCheck = fieldCheck && (lhs.hasDoubleValue == rhs.hasDoubleValue) && (!lhs.hasDoubleValue || lhs.doubleValue == rhs.doubleValue)
          fieldCheck = fieldCheck && (lhs.hasIntValue == rhs.hasIntValue) && (!lhs.hasIntValue || lhs.intValue == rhs.intValue)
          fieldCheck = fieldCheck && (lhs.hasUintValue == rhs.hasUintValue) && (!lhs.hasUintValue || lhs.uintValue == rhs.uintValue)
          fieldCheck = fieldCheck && (lhs.hasSintValue == rhs.hasSintValue) && (!lhs.hasSintValue || lhs.sintValue == rhs.sintValue)
          fieldCheck = fieldCheck && (lhs.hasBoolValue == rhs.hasBoolValue) && (!lhs.hasBoolValue || lhs.boolValue == rhs.boolValue)
          fieldCheck = fieldCheck && lhs.isEqualExtensionsInOther(otherMessage: rhs, startInclusive:8, endExclusive:536870912)
          fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
          return fieldCheck
        }

        // Exactly one of these values must be present in a valid message
        public fileprivate(set) var stringValue:String = ""
        public fileprivate(set) var hasStringValue:Bool = false

        public fileprivate(set) var floatValue:Float = Float(0)
        public fileprivate(set) var hasFloatValue:Bool = false

        public fileprivate(set) var doubleValue:Double = Double(0)
        public fileprivate(set) var hasDoubleValue:Bool = false

        public fileprivate(set) var intValue:Int64 = Int64(0)
        public fileprivate(set) var hasIntValue:Bool = false

        public fileprivate(set) var uintValue:UInt64 = UInt64(0)
        public fileprivate(set) var hasUintValue:Bool = false

        public fileprivate(set) var sintValue:Int64 = Int64(0)
        public fileprivate(set) var hasSintValue:Bool = false

        public fileprivate(set) var boolValue:Bool = false
        public fileprivate(set) var hasBoolValue:Bool = false

        required public init() {
             super.init()
        }
        override public func isInitialized() -> Bool {
          if !extensionsAreInitialized() {
            return false
          }
         return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
          if hasStringValue {
            try codedOutputStream.writeString(fieldNumber: 1, value:stringValue)
          }
          if hasFloatValue {
            try codedOutputStream.writeFloat(fieldNumber: 2, value:floatValue)
          }
          if hasDoubleValue {
            try codedOutputStream.writeDouble(fieldNumber: 3, value:doubleValue)
          }
          if hasIntValue {
            try codedOutputStream.writeInt64(fieldNumber: 4, value:intValue)
          }
          if hasUintValue {
            try codedOutputStream.writeUInt64(fieldNumber: 5, value:uintValue)
          }
          if hasSintValue {
            try codedOutputStream.writeSInt64(fieldNumber: 6, value:sintValue)
          }
          if hasBoolValue {
            try codedOutputStream.writeBool(fieldNumber: 7, value:boolValue)
          }
          try writeExtensionsTo(codedOutputStream: codedOutputStream, startInclusive:8, endExclusive:536870912)
          try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
          var serialize_size:Int32 = memoizedSerializedSize
          if serialize_size != -1 {
           return serialize_size
          }

          serialize_size = 0
          if hasStringValue {
            serialize_size += stringValue.computeStringSize(fieldNumber: 1)
          }
          if hasFloatValue {
            serialize_size += floatValue.computeFloatSize(fieldNumber: 2)
          }
          if hasDoubleValue {
            serialize_size += doubleValue.computeDoubleSize(fieldNumber: 3)
          }
          if hasIntValue {
            serialize_size += intValue.computeInt64Size(fieldNumber: 4)
          }
          if hasUintValue {
            serialize_size += uintValue.computeUInt64Size(fieldNumber: 5)
          }
          if hasSintValue {
            serialize_size += sintValue.computeSInt64Size(fieldNumber: 6)
          }
          if hasBoolValue {
            serialize_size += boolValue.computeBoolSize(fieldNumber: 7)
          }
          serialize_size += extensionsSerializedSize()
          serialize_size += unknownFields.serializedSize()
          memoizedSerializedSize = serialize_size
          return serialize_size
        }
        public class func getBuilder() -> VectorTile.Tile.Value.Builder {
          return VectorTile.Tile.Value.classBuilder() as! VectorTile.Tile.Value.Builder
        }
        public func getBuilder() -> VectorTile.Tile.Value.Builder {
          return classBuilder() as! VectorTile.Tile.Value.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
          return VectorTile.Tile.Value.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
          return VectorTile.Tile.Value.Builder()
        }
        public func toBuilder() throws -> VectorTile.Tile.Value.Builder {
          return try VectorTile.Tile.Value.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:VectorTile.Tile.Value) throws -> VectorTile.Tile.Value.Builder {
          return try VectorTile.Tile.Value.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
          guard isInitialized() else {
            throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
          }

          var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
          if hasStringValue {
            jsonMap["stringValue"] = stringValue
          }
          if hasFloatValue {
            jsonMap["floatValue"] = Float(floatValue)
          }
          if hasDoubleValue {
            jsonMap["doubleValue"] = Double(doubleValue)
          }
          if hasIntValue {
            jsonMap["intValue"] = "\(intValue)"
          }
          if hasUintValue {
            jsonMap["uintValue"] = "\(uintValue)"
          }
          if hasSintValue {
            jsonMap["sintValue"] = "\(sintValue)"
          }
          if hasBoolValue {
            jsonMap["boolValue"] = boolValue
          }
          return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> VectorTile.Tile.Value {
          return try VectorTile.Tile.Value.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> VectorTile.Tile.Value {
          return try VectorTile.Tile.Value.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
          var output = ""
          if hasStringValue {
            output += "\(indent) stringValue: \(stringValue) \n"
          }
          if hasFloatValue {
            output += "\(indent) floatValue: \(floatValue) \n"
          }
          if hasDoubleValue {
            output += "\(indent) doubleValue: \(doubleValue) \n"
          }
          if hasIntValue {
            output += "\(indent) intValue: \(intValue) \n"
          }
          if hasUintValue {
            output += "\(indent) uintValue: \(uintValue) \n"
          }
          if hasSintValue {
            output += "\(indent) sintValue: \(sintValue) \n"
          }
          if hasBoolValue {
            output += "\(indent) boolValue: \(boolValue) \n"
          }
          output += try getExtensionDescription(startInclusive:8, endExclusive:536870912, indent:indent)
          output += unknownFields.getDescription(indent: indent)
          return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasStringValue {
                   hashCode = (hashCode &* 31) &+ stringValue.hashValue
                }
                if hasFloatValue {
                   hashCode = (hashCode &* 31) &+ floatValue.hashValue
                }
                if hasDoubleValue {
                   hashCode = (hashCode &* 31) &+ doubleValue.hashValue
                }
                if hasIntValue {
                   hashCode = (hashCode &* 31) &+ intValue.hashValue
                }
                if hasUintValue {
                   hashCode = (hashCode &* 31) &+ uintValue.hashValue
                }
                if hasSintValue {
                   hashCode = (hashCode &* 31) &+ sintValue.hashValue
                }
                if hasBoolValue {
                   hashCode = (hashCode &* 31) &+ boolValue.hashValue
                }
                hashCode = (hashCode &* 31) &+ Int(hashExtensionsFrom(startInclusive: 8, endExclusive:536870912))
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "VectorTile.Tile.Value"
        }
        override public func className() -> String {
            return "VectorTile.Tile.Value"
        }
        //Meta information declaration end

        final public class Builder : ExtendableMessageBuilder {
          fileprivate var builderResult:VectorTile.Tile.Value = VectorTile.Tile.Value()
          public func getMessage() -> VectorTile.Tile.Value {
              return builderResult
          }

          required override public init () {
             super.init()
          }
          public var hasStringValue:Bool {
               get {
                    return builderResult.hasStringValue
               }
          }
          public var stringValue:String {
               get {
                    return builderResult.stringValue
               }
               set (value) {
                   builderResult.hasStringValue = true
                   builderResult.stringValue = value
               }
          }
          @discardableResult
          public func setStringValue(_ value:String) -> VectorTile.Tile.Value.Builder {
            self.stringValue = value
            return self
          }
          @discardableResult
          public func clearStringValue() -> VectorTile.Tile.Value.Builder{
               builderResult.hasStringValue = false
               builderResult.stringValue = ""
               return self
          }
          public var hasFloatValue:Bool {
               get {
                    return builderResult.hasFloatValue
               }
          }
          public var floatValue:Float {
               get {
                    return builderResult.floatValue
               }
               set (value) {
                   builderResult.hasFloatValue = true
                   builderResult.floatValue = value
               }
          }
          @discardableResult
          public func setFloatValue(_ value:Float) -> VectorTile.Tile.Value.Builder {
            self.floatValue = value
            return self
          }
          @discardableResult
          public func clearFloatValue() -> VectorTile.Tile.Value.Builder{
               builderResult.hasFloatValue = false
               builderResult.floatValue = Float(0)
               return self
          }
          public var hasDoubleValue:Bool {
               get {
                    return builderResult.hasDoubleValue
               }
          }
          public var doubleValue:Double {
               get {
                    return builderResult.doubleValue
               }
               set (value) {
                   builderResult.hasDoubleValue = true
                   builderResult.doubleValue = value
               }
          }
          @discardableResult
          public func setDoubleValue(_ value:Double) -> VectorTile.Tile.Value.Builder {
            self.doubleValue = value
            return self
          }
          @discardableResult
          public func clearDoubleValue() -> VectorTile.Tile.Value.Builder{
               builderResult.hasDoubleValue = false
               builderResult.doubleValue = Double(0)
               return self
          }
          public var hasIntValue:Bool {
               get {
                    return builderResult.hasIntValue
               }
          }
          public var intValue:Int64 {
               get {
                    return builderResult.intValue
               }
               set (value) {
                   builderResult.hasIntValue = true
                   builderResult.intValue = value
               }
          }
          @discardableResult
          public func setIntValue(_ value:Int64) -> VectorTile.Tile.Value.Builder {
            self.intValue = value
            return self
          }
          @discardableResult
          public func clearIntValue() -> VectorTile.Tile.Value.Builder{
               builderResult.hasIntValue = false
               builderResult.intValue = Int64(0)
               return self
          }
          public var hasUintValue:Bool {
               get {
                    return builderResult.hasUintValue
               }
          }
          public var uintValue:UInt64 {
               get {
                    return builderResult.uintValue
               }
               set (value) {
                   builderResult.hasUintValue = true
                   builderResult.uintValue = value
               }
          }
          @discardableResult
          public func setUintValue(_ value:UInt64) -> VectorTile.Tile.Value.Builder {
            self.uintValue = value
            return self
          }
          @discardableResult
          public func clearUintValue() -> VectorTile.Tile.Value.Builder{
               builderResult.hasUintValue = false
               builderResult.uintValue = UInt64(0)
               return self
          }
          public var hasSintValue:Bool {
               get {
                    return builderResult.hasSintValue
               }
          }
          public var sintValue:Int64 {
               get {
                    return builderResult.sintValue
               }
               set (value) {
                   builderResult.hasSintValue = true
                   builderResult.sintValue = value
               }
          }
          @discardableResult
          public func setSintValue(_ value:Int64) -> VectorTile.Tile.Value.Builder {
            self.sintValue = value
            return self
          }
          @discardableResult
          public func clearSintValue() -> VectorTile.Tile.Value.Builder{
               builderResult.hasSintValue = false
               builderResult.sintValue = Int64(0)
               return self
          }
          public var hasBoolValue:Bool {
               get {
                    return builderResult.hasBoolValue
               }
          }
          public var boolValue:Bool {
               get {
                    return builderResult.boolValue
               }
               set (value) {
                   builderResult.hasBoolValue = true
                   builderResult.boolValue = value
               }
          }
          @discardableResult
          public func setBoolValue(_ value:Bool) -> VectorTile.Tile.Value.Builder {
            self.boolValue = value
            return self
          }
          @discardableResult
          public func clearBoolValue() -> VectorTile.Tile.Value.Builder{
               builderResult.hasBoolValue = false
               builderResult.boolValue = false
               return self
          }
          override public var internalGetResult:ExtendableMessage {
               get {
                   return builderResult
               }
          }
          @discardableResult
          override public func clear() -> VectorTile.Tile.Value.Builder {
            builderResult = VectorTile.Tile.Value()
            return self
          }
          override public func clone() throws -> VectorTile.Tile.Value.Builder {
            return try VectorTile.Tile.Value.builderWithPrototype(prototype:builderResult)
          }
          override public func build() throws -> VectorTile.Tile.Value {
               try checkInitialized()
               return buildPartial()
          }
          public func buildPartial() -> VectorTile.Tile.Value {
            let returnMe:VectorTile.Tile.Value = builderResult
            return returnMe
          }
          @discardableResult
          public func mergeFrom(other:VectorTile.Tile.Value) throws -> VectorTile.Tile.Value.Builder {
            if other == VectorTile.Tile.Value() {
             return self
            }
            if other.hasStringValue {
                 stringValue = other.stringValue
            }
            if other.hasFloatValue {
                 floatValue = other.floatValue
            }
            if other.hasDoubleValue {
                 doubleValue = other.doubleValue
            }
            if other.hasIntValue {
                 intValue = other.intValue
            }
            if other.hasUintValue {
                 uintValue = other.uintValue
            }
            if other.hasSintValue {
                 sintValue = other.sintValue
            }
            if other.hasBoolValue {
                 boolValue = other.boolValue
            }
            try mergeExtensionFields(other: other)
            try merge(unknownField: other.unknownFields)
            return self
          }
          @discardableResult
          override public func mergeFrom(codedInputStream: CodedInputStream) throws -> VectorTile.Tile.Value.Builder {
               return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
          }
          @discardableResult
          override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> VectorTile.Tile.Value.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
              let protobufTag = try codedInputStream.readTag()
              switch protobufTag {
              case 0: 
                self.unknownFields = try unknownFieldsBuilder.build()
                return self

              case 10:
                stringValue = try codedInputStream.readString()

              case 21:
                floatValue = try codedInputStream.readFloat()

              case 25:
                doubleValue = try codedInputStream.readDouble()

              case 32:
                intValue = try codedInputStream.readInt64()

              case 40:
                uintValue = try codedInputStream.readUInt64()

              case 48:
                sintValue = try codedInputStream.readSInt64()

              case 56:
                boolValue = try codedInputStream.readBool()

              default:
                if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                   unknownFields = try unknownFieldsBuilder.build()
                   return self
                }
              }
            }
          }
          class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> VectorTile.Tile.Value.Builder {
            let resultDecodedBuilder = VectorTile.Tile.Value.Builder()
            if let jsonValueStringValue = jsonMap["stringValue"] as? String {
              resultDecodedBuilder.stringValue = jsonValueStringValue
            }
            if let jsonValueFloatValue = jsonMap["floatValue"] as? Float {
              resultDecodedBuilder.floatValue = Float(jsonValueFloatValue)
            }
            if let jsonValueDoubleValue = jsonMap["doubleValue"] as? Double {
              resultDecodedBuilder.doubleValue = Double(jsonValueDoubleValue)
            }
            if let jsonValueIntValue = jsonMap["intValue"] as? String {
              resultDecodedBuilder.intValue = Int64(jsonValueIntValue)!
            }
            if let jsonValueUintValue = jsonMap["uintValue"] as? String {
              resultDecodedBuilder.uintValue = UInt64(jsonValueUintValue)!
            }
            if let jsonValueSintValue = jsonMap["sintValue"] as? String {
              resultDecodedBuilder.sintValue = Int64(jsonValueSintValue)!
            }
            if let jsonValueBoolValue = jsonMap["boolValue"] as? Bool {
              resultDecodedBuilder.boolValue = jsonValueBoolValue
            }
            return resultDecodedBuilder
          }
          override class public func fromJSONToBuilder(data:Data) throws -> VectorTile.Tile.Value.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try VectorTile.Tile.Value.Builder.decodeToBuilder(jsonMap:jsDataCast)
          }
        }

      }

    //Nested type declaration end



    //Nested type declaration start

      // Features are described in section 4.2 of the specification
      final public class Feature : GeneratedMessage {

        public static func == (lhs: VectorTile.Tile.Feature, rhs: VectorTile.Tile.Feature) -> Bool {
          if (lhs === rhs) {
            return true
          }
          var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
          fieldCheck = fieldCheck && (lhs.hasId == rhs.hasId) && (!lhs.hasId || lhs.id == rhs.id)
          fieldCheck = fieldCheck && (lhs.tags == rhs.tags)
          fieldCheck = fieldCheck && (lhs.hasType == rhs.hasType) && (!lhs.hasType || lhs.type == rhs.type)
          fieldCheck = fieldCheck && (lhs.geometry == rhs.geometry)
          fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
          return fieldCheck
        }

        public fileprivate(set) var id:UInt64 = UInt64(0)
        public fileprivate(set) var hasId:Bool = false

        // Tags of this feature are encoded as repeated pairs of
        // integers.
        // A detailed description of tags is located in sections
        // 4.2 and 4.4 of the specification
        public fileprivate(set) var tags:Array<UInt32> = Array<UInt32>()
        private var tagsMemoizedSerializedSize:Int32 = -1
        public fileprivate(set) var type:VectorTile.Tile.GeomType = VectorTile.Tile.GeomType.unknown
        public fileprivate(set) var hasType:Bool = false
        // Contains a stream of commands and parameters (vertices).
        // A detailed description on geometry encoding is located in
        // section 4.3 of the specification.
        public fileprivate(set) var geometry:Array<UInt32> = Array<UInt32>()
        private var geometryMemoizedSerializedSize:Int32 = -1
        required public init() {
             super.init()
        }
        override public func isInitialized() -> Bool {
         return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
          if hasId {
            try codedOutputStream.writeUInt64(fieldNumber: 1, value:id)
          }
          if !tags.isEmpty {
            try codedOutputStream.writeRawVarint32(value: 18)
            try codedOutputStream.writeRawVarint32(value: tagsMemoizedSerializedSize)
            for oneValuetags in tags {
              try codedOutputStream.writeUInt32NoTag(value: oneValuetags)
            }
          }
          if hasType {
            try codedOutputStream.writeEnum(fieldNumber: 3, value:type.rawValue)
          }
          if !geometry.isEmpty {
            try codedOutputStream.writeRawVarint32(value: 34)
            try codedOutputStream.writeRawVarint32(value: geometryMemoizedSerializedSize)
            for oneValuegeometry in geometry {
              try codedOutputStream.writeUInt32NoTag(value: oneValuegeometry)
            }
          }
          try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
          var serialize_size:Int32 = memoizedSerializedSize
          if serialize_size != -1 {
           return serialize_size
          }

          serialize_size = 0
          if hasId {
            serialize_size += id.computeUInt64Size(fieldNumber: 1)
          }
          var dataSizeTags:Int32 = 0
          for oneValuetags in tags {
              dataSizeTags += oneValuetags.computeUInt32SizeNoTag()
          }
          serialize_size += dataSizeTags
          if !tags.isEmpty {
            serialize_size += 1
            serialize_size += dataSizeTags.computeInt32SizeNoTag()
          }
          tagsMemoizedSerializedSize = dataSizeTags
          if (hasType) {
            serialize_size += type.rawValue.computeEnumSize(fieldNumber: 3)
          }
          var dataSizeGeometry:Int32 = 0
          for oneValuegeometry in geometry {
              dataSizeGeometry += oneValuegeometry.computeUInt32SizeNoTag()
          }
          serialize_size += dataSizeGeometry
          if !geometry.isEmpty {
            serialize_size += 1
            serialize_size += dataSizeGeometry.computeInt32SizeNoTag()
          }
          geometryMemoizedSerializedSize = dataSizeGeometry
          serialize_size += unknownFields.serializedSize()
          memoizedSerializedSize = serialize_size
          return serialize_size
        }
        public class func getBuilder() -> VectorTile.Tile.Feature.Builder {
          return VectorTile.Tile.Feature.classBuilder() as! VectorTile.Tile.Feature.Builder
        }
        public func getBuilder() -> VectorTile.Tile.Feature.Builder {
          return classBuilder() as! VectorTile.Tile.Feature.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
          return VectorTile.Tile.Feature.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
          return VectorTile.Tile.Feature.Builder()
        }
        public func toBuilder() throws -> VectorTile.Tile.Feature.Builder {
          return try VectorTile.Tile.Feature.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:VectorTile.Tile.Feature) throws -> VectorTile.Tile.Feature.Builder {
          return try VectorTile.Tile.Feature.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
          guard isInitialized() else {
            throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
          }

          var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
          if hasId {
            jsonMap["id"] = "\(id)"
          }
          if !tags.isEmpty {
            var jsonArrayTags:Array<UInt> = []
              for oneValueTags in tags {
                jsonArrayTags.append(UInt(oneValueTags))
              }
            jsonMap["tags"] = jsonArrayTags
          }
          if hasType {
            jsonMap["type"] = type.toString()
          }
          if !geometry.isEmpty {
            var jsonArrayGeometry:Array<UInt> = []
              for oneValueGeometry in geometry {
                jsonArrayGeometry.append(UInt(oneValueGeometry))
              }
            jsonMap["geometry"] = jsonArrayGeometry
          }
          return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> VectorTile.Tile.Feature {
          return try VectorTile.Tile.Feature.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> VectorTile.Tile.Feature {
          return try VectorTile.Tile.Feature.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
          var output = ""
          if hasId {
            output += "\(indent) id: \(id) \n"
          }
          var tagsElementIndex:Int = 0
          for oneValueTags in tags  {
              output += "\(indent) tags[\(tagsElementIndex)]: \(oneValueTags)\n"
              tagsElementIndex += 1
          }
          if (hasType) {
            output += "\(indent) type: \(type.description)\n"
          }
          var geometryElementIndex:Int = 0
          for oneValueGeometry in geometry  {
              output += "\(indent) geometry[\(geometryElementIndex)]: \(oneValueGeometry)\n"
              geometryElementIndex += 1
          }
          output += unknownFields.getDescription(indent: indent)
          return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasId {
                   hashCode = (hashCode &* 31) &+ id.hashValue
                }
                for oneValueTags in tags {
                    hashCode = (hashCode &* 31) &+ oneValueTags.hashValue
                }
                if hasType {
                   hashCode = (hashCode &* 31) &+ Int(type.rawValue)
                }
                for oneValueGeometry in geometry {
                    hashCode = (hashCode &* 31) &+ oneValueGeometry.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "VectorTile.Tile.Feature"
        }
        override public func className() -> String {
            return "VectorTile.Tile.Feature"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
          fileprivate var builderResult:VectorTile.Tile.Feature = VectorTile.Tile.Feature()
          public func getMessage() -> VectorTile.Tile.Feature {
              return builderResult
          }

          required override public init () {
             super.init()
          }
          public var hasId:Bool {
               get {
                    return builderResult.hasId
               }
          }
          public var id:UInt64 {
               get {
                    return builderResult.id
               }
               set (value) {
                   builderResult.hasId = true
                   builderResult.id = value
               }
          }
          @discardableResult
          public func setId(_ value:UInt64) -> VectorTile.Tile.Feature.Builder {
            self.id = value
            return self
          }
          @discardableResult
          public func clearId() -> VectorTile.Tile.Feature.Builder{
               builderResult.hasId = false
               builderResult.id = UInt64(0)
               return self
          }
          public var tags:Array<UInt32> {
               get {
                   return builderResult.tags
               }
               set (array) {
                   builderResult.tags = array
               }
          }
          @discardableResult
          public func setTags(_ value:Array<UInt32>) -> VectorTile.Tile.Feature.Builder {
            self.tags = value
            return self
          }
          @discardableResult
          public func clearTags() -> VectorTile.Tile.Feature.Builder {
             builderResult.tags.removeAll(keepingCapacity: false)
             return self
          }
            public var hasType:Bool{
                get {
                    return builderResult.hasType
                }
            }
            public var type:VectorTile.Tile.GeomType {
                get {
                    return builderResult.type
                }
                set (value) {
                    builderResult.hasType = true
                    builderResult.type = value
                }
            }
          @discardableResult
            public func setType(_ value:VectorTile.Tile.GeomType) -> VectorTile.Tile.Feature.Builder {
              self.type = value
              return self
            }
          @discardableResult
            public func clearType() -> VectorTile.Tile.Feature.Builder {
               builderResult.hasType = false
               builderResult.type = .unknown
               return self
            }
          public var geometry:Array<UInt32> {
               get {
                   return builderResult.geometry
               }
               set (array) {
                   builderResult.geometry = array
               }
          }
          @discardableResult
          public func setGeometry(_ value:Array<UInt32>) -> VectorTile.Tile.Feature.Builder {
            self.geometry = value
            return self
          }
          @discardableResult
          public func clearGeometry() -> VectorTile.Tile.Feature.Builder {
             builderResult.geometry.removeAll(keepingCapacity: false)
             return self
          }
          override public var internalGetResult:GeneratedMessage {
               get {
                  return builderResult
               }
          }
          @discardableResult
          override public func clear() -> VectorTile.Tile.Feature.Builder {
            builderResult = VectorTile.Tile.Feature()
            return self
          }
          override public func clone() throws -> VectorTile.Tile.Feature.Builder {
            return try VectorTile.Tile.Feature.builderWithPrototype(prototype:builderResult)
          }
          override public func build() throws -> VectorTile.Tile.Feature {
               try checkInitialized()
               return buildPartial()
          }
          public func buildPartial() -> VectorTile.Tile.Feature {
            let returnMe:VectorTile.Tile.Feature = builderResult
            return returnMe
          }
          @discardableResult
          public func mergeFrom(other:VectorTile.Tile.Feature) throws -> VectorTile.Tile.Feature.Builder {
            if other == VectorTile.Tile.Feature() {
             return self
            }
            if other.hasId {
                 id = other.id
            }
            if !other.tags.isEmpty {
                builderResult.tags += other.tags
            }
            if other.hasType {
                 type = other.type
            }
            if !other.geometry.isEmpty {
                builderResult.geometry += other.geometry
            }
            try merge(unknownField: other.unknownFields)
            return self
          }
          @discardableResult
          override public func mergeFrom(codedInputStream: CodedInputStream) throws -> VectorTile.Tile.Feature.Builder {
               return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
          }
          @discardableResult
          override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> VectorTile.Tile.Feature.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
              let protobufTag = try codedInputStream.readTag()
              switch protobufTag {
              case 0: 
                self.unknownFields = try unknownFieldsBuilder.build()
                return self

              case 8:
                id = try codedInputStream.readUInt64()

              case 18:
                let length = Int(try codedInputStream.readRawVarint32())
                let limit = try codedInputStream.pushLimit(byteLimit: length)
                while (codedInputStream.bytesUntilLimit() > 0) {
                  builderResult.tags.append(try codedInputStream.readUInt32())
                }
                codedInputStream.popLimit(oldLimit: limit)

              case 24:
                let valueInttype = try codedInputStream.readEnum()
                if let enumstype = VectorTile.Tile.GeomType(rawValue:valueInttype){
                     type = enumstype
                } else {
                     try unknownFieldsBuilder.mergeVarintField(fieldNumber: 3, value:Int64(valueInttype))
                }

              case 34:
                let length = Int(try codedInputStream.readRawVarint32())
                let limit = try codedInputStream.pushLimit(byteLimit: length)
                while (codedInputStream.bytesUntilLimit() > 0) {
                  builderResult.geometry.append(try codedInputStream.readUInt32())
                }
                codedInputStream.popLimit(oldLimit: limit)

              default:
                if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                   unknownFields = try unknownFieldsBuilder.build()
                   return self
                }
              }
            }
          }
          class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> VectorTile.Tile.Feature.Builder {
            let resultDecodedBuilder = VectorTile.Tile.Feature.Builder()
            if let jsonValueId = jsonMap["id"] as? String {
              resultDecodedBuilder.id = UInt64(jsonValueId)!
            }
            if let jsonValueTags = jsonMap["tags"] as? Array<UInt> {
              var jsonArrayTags:Array<UInt32> = []
              for oneValueTags in jsonValueTags {
                jsonArrayTags.append(UInt32(oneValueTags))
              }
              resultDecodedBuilder.tags = jsonArrayTags
            }
            if let jsonValueType = jsonMap["type"] as? String {
              resultDecodedBuilder.type = try VectorTile.Tile.GeomType.fromString(str: jsonValueType)
            }
            if let jsonValueGeometry = jsonMap["geometry"] as? Array<UInt> {
              var jsonArrayGeometry:Array<UInt32> = []
              for oneValueGeometry in jsonValueGeometry {
                jsonArrayGeometry.append(UInt32(oneValueGeometry))
              }
              resultDecodedBuilder.geometry = jsonArrayGeometry
            }
            return resultDecodedBuilder
          }
          override class public func fromJSONToBuilder(data:Data) throws -> VectorTile.Tile.Feature.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try VectorTile.Tile.Feature.Builder.decodeToBuilder(jsonMap:jsDataCast)
          }
        }

      }

    //Nested type declaration end



    //Nested type declaration start

      // Layers are described in section 4.1 of the specification
      final public class Layer : ExtendableMessage {

        public static func == (lhs: VectorTile.Tile.Layer, rhs: VectorTile.Tile.Layer) -> Bool {
          if (lhs === rhs) {
            return true
          }
          var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
          fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
          fieldCheck = fieldCheck && (lhs.features == rhs.features)
          fieldCheck = fieldCheck && (lhs.keys == rhs.keys)
          fieldCheck = fieldCheck && (lhs.values == rhs.values)
          fieldCheck = fieldCheck && (lhs.hasExtent == rhs.hasExtent) && (!lhs.hasExtent || lhs.extent == rhs.extent)
          fieldCheck = fieldCheck && (lhs.hasVersion == rhs.hasVersion) && (!lhs.hasVersion || lhs.version == rhs.version)
          fieldCheck = fieldCheck && lhs.isEqualExtensionsInOther(otherMessage: rhs, startInclusive:16, endExclusive:536870912)
          fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
          return fieldCheck
        }

        // Any compliant implementation must first read the version
        // number encoded in this message and choose the correct
        // implementation for this version number before proceeding to
        // decode other parts of this message.
        public fileprivate(set) var version:UInt32 = UInt32(1)
        public fileprivate(set) var hasVersion:Bool = false

        public fileprivate(set) var name:String = ""
        public fileprivate(set) var hasName:Bool = false

        public fileprivate(set) var features:Array<VectorTile.Tile.Feature>  = Array<VectorTile.Tile.Feature>()
        // Dictionary encoding for keys
        public fileprivate(set) var keys:Array<String> = Array<String>()
        public fileprivate(set) var values:Array<VectorTile.Tile.Value>  = Array<VectorTile.Tile.Value>()
        // Although this is an "optional" field it is required by the specification.
        // See https://github.com/mapbox/vector-tile-spec/issues/47
        public fileprivate(set) var extent:UInt32 = UInt32(4096)
        public fileprivate(set) var hasExtent:Bool = false

        required public init() {
             super.init()
        }
        override public func isInitialized() -> Bool {
          if !hasVersion {
            return false
          }
          if !hasName {
            return false
          }
          var isInitValues:Bool = true
          for oneElementValues in values {
            if !oneElementValues.isInitialized() {
              isInitValues = false
              break 
            }
          }
          if !isInitValues {
            return isInitValues
          }
          if !extensionsAreInitialized() {
            return false
          }
         return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
          if hasName {
            try codedOutputStream.writeString(fieldNumber: 1, value:name)
          }
          for oneElementFeatures in features {
              try codedOutputStream.writeMessage(fieldNumber: 2, value:oneElementFeatures)
          }
          if !keys.isEmpty {
            for oneValuekeys in keys {
              try codedOutputStream.writeString(fieldNumber: 3, value:oneValuekeys)
            }
          }
          for oneElementValues in values {
              try codedOutputStream.writeMessage(fieldNumber: 4, value:oneElementValues)
          }
          if hasExtent {
            try codedOutputStream.writeUInt32(fieldNumber: 5, value:extent)
          }
          if hasVersion {
            try codedOutputStream.writeUInt32(fieldNumber: 15, value:version)
          }
          try writeExtensionsTo(codedOutputStream: codedOutputStream, startInclusive:16, endExclusive:536870912)
          try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
          var serialize_size:Int32 = memoizedSerializedSize
          if serialize_size != -1 {
           return serialize_size
          }

          serialize_size = 0
          if hasName {
            serialize_size += name.computeStringSize(fieldNumber: 1)
          }
          for oneElementFeatures in features {
              serialize_size += oneElementFeatures.computeMessageSize(fieldNumber: 2)
          }
          var dataSizeKeys:Int32 = 0
          for oneValuekeys in keys {
              dataSizeKeys += oneValuekeys.computeStringSizeNoTag()
          }
          serialize_size += dataSizeKeys
          serialize_size += 1 * Int32(keys.count)
          for oneElementValues in values {
              serialize_size += oneElementValues.computeMessageSize(fieldNumber: 4)
          }
          if hasExtent {
            serialize_size += extent.computeUInt32Size(fieldNumber: 5)
          }
          if hasVersion {
            serialize_size += version.computeUInt32Size(fieldNumber: 15)
          }
          serialize_size += extensionsSerializedSize()
          serialize_size += unknownFields.serializedSize()
          memoizedSerializedSize = serialize_size
          return serialize_size
        }
        public class func getBuilder() -> VectorTile.Tile.Layer.Builder {
          return VectorTile.Tile.Layer.classBuilder() as! VectorTile.Tile.Layer.Builder
        }
        public func getBuilder() -> VectorTile.Tile.Layer.Builder {
          return classBuilder() as! VectorTile.Tile.Layer.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
          return VectorTile.Tile.Layer.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
          return VectorTile.Tile.Layer.Builder()
        }
        public func toBuilder() throws -> VectorTile.Tile.Layer.Builder {
          return try VectorTile.Tile.Layer.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:VectorTile.Tile.Layer) throws -> VectorTile.Tile.Layer.Builder {
          return try VectorTile.Tile.Layer.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
          guard isInitialized() else {
            throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
          }

          var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
          if hasVersion {
            jsonMap["version"] = UInt(version)
          }
          if hasName {
            jsonMap["name"] = name
          }
          if !features.isEmpty {
            var jsonArrayFeatures:Array<Dictionary<String,Any>> = []
              for oneValueFeatures in features {
                let ecodedMessageFeatures = try oneValueFeatures.encode()
                jsonArrayFeatures.append(ecodedMessageFeatures)
              }
            jsonMap["features"] = jsonArrayFeatures
          }
          if !keys.isEmpty {
            var jsonArrayKeys:Array<String> = []
              for oneValueKeys in keys {
                jsonArrayKeys.append(oneValueKeys)
              }
            jsonMap["keys"] = jsonArrayKeys
          }
          if !values.isEmpty {
            var jsonArrayValues:Array<Dictionary<String,Any>> = []
              for oneValueValues in values {
                let ecodedMessageValues = try oneValueValues.encode()
                jsonArrayValues.append(ecodedMessageValues)
              }
            jsonMap["values"] = jsonArrayValues
          }
          if hasExtent {
            jsonMap["extent"] = UInt(extent)
          }
          return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> VectorTile.Tile.Layer {
          return try VectorTile.Tile.Layer.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> VectorTile.Tile.Layer {
          return try VectorTile.Tile.Layer.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
          var output = ""
          if hasName {
            output += "\(indent) name: \(name) \n"
          }
          var featuresElementIndex:Int = 0
          for oneElementFeatures in features {
              output += "\(indent) features[\(featuresElementIndex)] {\n"
              output += try oneElementFeatures.getDescription(indent: "\(indent)  ")
              output += "\(indent)}\n"
              featuresElementIndex += 1
          }
          var keysElementIndex:Int = 0
          for oneValueKeys in keys  {
              output += "\(indent) keys[\(keysElementIndex)]: \(oneValueKeys)\n"
              keysElementIndex += 1
          }
          var valuesElementIndex:Int = 0
          for oneElementValues in values {
              output += "\(indent) values[\(valuesElementIndex)] {\n"
              output += try oneElementValues.getDescription(indent: "\(indent)  ")
              output += "\(indent)}\n"
              valuesElementIndex += 1
          }
          if hasExtent {
            output += "\(indent) extent: \(extent) \n"
          }
          if hasVersion {
            output += "\(indent) version: \(version) \n"
          }
          output += try getExtensionDescription(startInclusive:16, endExclusive:536870912, indent:indent)
          output += unknownFields.getDescription(indent: indent)
          return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasName {
                   hashCode = (hashCode &* 31) &+ name.hashValue
                }
                for oneElementFeatures in features {
                    hashCode = (hashCode &* 31) &+ oneElementFeatures.hashValue
                }
                for oneValueKeys in keys {
                    hashCode = (hashCode &* 31) &+ oneValueKeys.hashValue
                }
                for oneElementValues in values {
                    hashCode = (hashCode &* 31) &+ oneElementValues.hashValue
                }
                if hasExtent {
                   hashCode = (hashCode &* 31) &+ extent.hashValue
                }
                if hasVersion {
                   hashCode = (hashCode &* 31) &+ version.hashValue
                }
                hashCode = (hashCode &* 31) &+ Int(hashExtensionsFrom(startInclusive: 16, endExclusive:536870912))
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "VectorTile.Tile.Layer"
        }
        override public func className() -> String {
            return "VectorTile.Tile.Layer"
        }
        //Meta information declaration end

        final public class Builder : ExtendableMessageBuilder {
          fileprivate var builderResult:VectorTile.Tile.Layer = VectorTile.Tile.Layer()
          public func getMessage() -> VectorTile.Tile.Layer {
              return builderResult
          }

          required override public init () {
             super.init()
          }
          public var hasVersion:Bool {
               get {
                    return builderResult.hasVersion
               }
          }
          public var version:UInt32 {
               get {
                    return builderResult.version
               }
               set (value) {
                   builderResult.hasVersion = true
                   builderResult.version = value
               }
          }
          @discardableResult
          public func setVersion(_ value:UInt32) -> VectorTile.Tile.Layer.Builder {
            self.version = value
            return self
          }
          @discardableResult
          public func clearVersion() -> VectorTile.Tile.Layer.Builder{
               builderResult.hasVersion = false
               builderResult.version = UInt32(1)
               return self
          }
          public var hasName:Bool {
               get {
                    return builderResult.hasName
               }
          }
          public var name:String {
               get {
                    return builderResult.name
               }
               set (value) {
                   builderResult.hasName = true
                   builderResult.name = value
               }
          }
          @discardableResult
          public func setName(_ value:String) -> VectorTile.Tile.Layer.Builder {
            self.name = value
            return self
          }
          @discardableResult
          public func clearName() -> VectorTile.Tile.Layer.Builder{
               builderResult.hasName = false
               builderResult.name = ""
               return self
          }
          public var features:Array<VectorTile.Tile.Feature> {
               get {
                   return builderResult.features
               }
               set (value) {
                   builderResult.features = value
               }
          }
          @discardableResult
          public func setFeatures(_ value:Array<VectorTile.Tile.Feature>) -> VectorTile.Tile.Layer.Builder {
            self.features = value
            return self
          }
          @discardableResult
          public func clearFeatures() -> VectorTile.Tile.Layer.Builder {
            builderResult.features.removeAll(keepingCapacity: false)
            return self
          }
          public var keys:Array<String> {
               get {
                   return builderResult.keys
               }
               set (array) {
                   builderResult.keys = array
               }
          }
          @discardableResult
          public func setKeys(_ value:Array<String>) -> VectorTile.Tile.Layer.Builder {
            self.keys = value
            return self
          }
          @discardableResult
          public func clearKeys() -> VectorTile.Tile.Layer.Builder {
             builderResult.keys.removeAll(keepingCapacity: false)
             return self
          }
          public var values:Array<VectorTile.Tile.Value> {
               get {
                   return builderResult.values
               }
               set (value) {
                   builderResult.values = value
               }
          }
          @discardableResult
          public func setValues(_ value:Array<VectorTile.Tile.Value>) -> VectorTile.Tile.Layer.Builder {
            self.values = value
            return self
          }
          @discardableResult
          public func clearValues() -> VectorTile.Tile.Layer.Builder {
            builderResult.values.removeAll(keepingCapacity: false)
            return self
          }
          public var hasExtent:Bool {
               get {
                    return builderResult.hasExtent
               }
          }
          public var extent:UInt32 {
               get {
                    return builderResult.extent
               }
               set (value) {
                   builderResult.hasExtent = true
                   builderResult.extent = value
               }
          }
          @discardableResult
          public func setExtent(_ value:UInt32) -> VectorTile.Tile.Layer.Builder {
            self.extent = value
            return self
          }
          @discardableResult
          public func clearExtent() -> VectorTile.Tile.Layer.Builder{
               builderResult.hasExtent = false
               builderResult.extent = UInt32(4096)
               return self
          }
          override public var internalGetResult:ExtendableMessage {
               get {
                   return builderResult
               }
          }
          @discardableResult
          override public func clear() -> VectorTile.Tile.Layer.Builder {
            builderResult = VectorTile.Tile.Layer()
            return self
          }
          override public func clone() throws -> VectorTile.Tile.Layer.Builder {
            return try VectorTile.Tile.Layer.builderWithPrototype(prototype:builderResult)
          }
          override public func build() throws -> VectorTile.Tile.Layer {
               try checkInitialized()
               return buildPartial()
          }
          public func buildPartial() -> VectorTile.Tile.Layer {
            let returnMe:VectorTile.Tile.Layer = builderResult
            return returnMe
          }
          @discardableResult
          public func mergeFrom(other:VectorTile.Tile.Layer) throws -> VectorTile.Tile.Layer.Builder {
            if other == VectorTile.Tile.Layer() {
             return self
            }
            if other.hasVersion {
                 version = other.version
            }
            if other.hasName {
                 name = other.name
            }
            if !other.features.isEmpty  {
               builderResult.features += other.features
            }
            if !other.keys.isEmpty {
                builderResult.keys += other.keys
            }
            if !other.values.isEmpty  {
               builderResult.values += other.values
            }
            if other.hasExtent {
                 extent = other.extent
            }
            try mergeExtensionFields(other: other)
            try merge(unknownField: other.unknownFields)
            return self
          }
          @discardableResult
          override public func mergeFrom(codedInputStream: CodedInputStream) throws -> VectorTile.Tile.Layer.Builder {
               return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
          }
          @discardableResult
          override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> VectorTile.Tile.Layer.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
              let protobufTag = try codedInputStream.readTag()
              switch protobufTag {
              case 0: 
                self.unknownFields = try unknownFieldsBuilder.build()
                return self

              case 10:
                name = try codedInputStream.readString()

              case 18:
                let subBuilder = VectorTile.Tile.Feature.Builder()
                try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                features.append(subBuilder.buildPartial())

              case 26:
                keys += [try codedInputStream.readString()]

              case 34:
                let subBuilder = VectorTile.Tile.Value.Builder()
                try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                values.append(subBuilder.buildPartial())

              case 40:
                extent = try codedInputStream.readUInt32()

              case 120:
                version = try codedInputStream.readUInt32()

              default:
                if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                   unknownFields = try unknownFieldsBuilder.build()
                   return self
                }
              }
            }
          }
          class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> VectorTile.Tile.Layer.Builder {
            let resultDecodedBuilder = VectorTile.Tile.Layer.Builder()
            if let jsonValueVersion = jsonMap["version"] as? UInt {
              resultDecodedBuilder.version = UInt32(jsonValueVersion)
            }
            if let jsonValueName = jsonMap["name"] as? String {
              resultDecodedBuilder.name = jsonValueName
            }
            if let jsonValueFeatures = jsonMap["features"] as? Array<Dictionary<String,Any>> {
              var jsonArrayFeatures:Array<VectorTile.Tile.Feature> = []
              for oneValueFeatures in jsonValueFeatures {
                let messageFromStringFeatures = try VectorTile.Tile.Feature.Builder.decodeToBuilder(jsonMap:oneValueFeatures).build()

                jsonArrayFeatures.append(messageFromStringFeatures)
              }
              resultDecodedBuilder.features = jsonArrayFeatures
            }
            if let jsonValueKeys = jsonMap["keys"] as? Array<String> {
              var jsonArrayKeys:Array<String> = []
              for oneValueKeys in jsonValueKeys {
                jsonArrayKeys.append(oneValueKeys)
              }
              resultDecodedBuilder.keys = jsonArrayKeys
            }
            if let jsonValueValues = jsonMap["values"] as? Array<Dictionary<String,Any>> {
              var jsonArrayValues:Array<VectorTile.Tile.Value> = []
              for oneValueValues in jsonValueValues {
                let messageFromStringValues = try VectorTile.Tile.Value.Builder.decodeToBuilder(jsonMap:oneValueValues).build()

                jsonArrayValues.append(messageFromStringValues)
              }
              resultDecodedBuilder.values = jsonArrayValues
            }
            if let jsonValueExtent = jsonMap["extent"] as? UInt {
              resultDecodedBuilder.extent = UInt32(jsonValueExtent)
            }
            return resultDecodedBuilder
          }
          override class public func fromJSONToBuilder(data:Data) throws -> VectorTile.Tile.Layer.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try VectorTile.Tile.Layer.Builder.decodeToBuilder(jsonMap:jsDataCast)
          }
        }

      }

    //Nested type declaration end



      //Enum type declaration start 

      // GeomType is described in section 4.3.4 of the specification
      public enum GeomType:Int32, CustomDebugStringConvertible, CustomStringConvertible {
        case unknown = 0
        case point = 1
        case linestring = 2
        case polygon = 3
        public func toString() -> String {
          switch self {
          case .unknown: return "UNKNOWN"
          case .point: return "POINT"
          case .linestring: return "LINESTRING"
          case .polygon: return "POLYGON"
          }
        }
        public static func fromString(str:String) throws -> VectorTile.Tile.GeomType {
          switch str {
          case "UNKNOWN":  return .unknown
          case "POINT":  return .point
          case "LINESTRING":  return .linestring
          case "POLYGON":  return .polygon
          default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
          }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
          switch self {
          case .unknown: return ".unknown"
          case .point: return ".point"
          case .linestring: return ".linestring"
          case .polygon: return ".polygon"
          }
        }
      }

      //Enum type declaration end 

    public fileprivate(set) var layers:Array<VectorTile.Tile.Layer>  = Array<VectorTile.Tile.Layer>()
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
      var isInitLayers:Bool = true
      for oneElementLayers in layers {
        if !oneElementLayers.isInitialized() {
          isInitLayers = false
          break 
        }
      }
      if !isInitLayers {
        return isInitLayers
      }
      if !extensionsAreInitialized() {
        return false
      }
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      for oneElementLayers in layers {
          try codedOutputStream.writeMessage(fieldNumber: 3, value:oneElementLayers)
      }
      try writeExtensionsTo(codedOutputStream: codedOutputStream, startInclusive:16, endExclusive:8192)
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      for oneElementLayers in layers {
          serialize_size += oneElementLayers.computeMessageSize(fieldNumber: 3)
      }
      serialize_size += extensionsSerializedSize()
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> VectorTile.Tile.Builder {
      return VectorTile.Tile.classBuilder() as! VectorTile.Tile.Builder
    }
    public func getBuilder() -> VectorTile.Tile.Builder {
      return classBuilder() as! VectorTile.Tile.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return VectorTile.Tile.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return VectorTile.Tile.Builder()
    }
    public func toBuilder() throws -> VectorTile.Tile.Builder {
      return try VectorTile.Tile.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:VectorTile.Tile) throws -> VectorTile.Tile.Builder {
      return try VectorTile.Tile.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if !layers.isEmpty {
        var jsonArrayLayers:Array<Dictionary<String,Any>> = []
          for oneValueLayers in layers {
            let ecodedMessageLayers = try oneValueLayers.encode()
            jsonArrayLayers.append(ecodedMessageLayers)
          }
        jsonMap["layers"] = jsonArrayLayers
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> VectorTile.Tile {
      return try VectorTile.Tile.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> VectorTile.Tile {
      return try VectorTile.Tile.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      var layersElementIndex:Int = 0
      for oneElementLayers in layers {
          output += "\(indent) layers[\(layersElementIndex)] {\n"
          output += try oneElementLayers.getDescription(indent: "\(indent)  ")
          output += "\(indent)}\n"
          layersElementIndex += 1
      }
      output += try getExtensionDescription(startInclusive:16, endExclusive:8192, indent:indent)
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            for oneElementLayers in layers {
                hashCode = (hashCode &* 31) &+ oneElementLayers.hashValue
            }
            hashCode = (hashCode &* 31) &+ Int(hashExtensionsFrom(startInclusive: 16, endExclusive:8192))
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "VectorTile.Tile"
    }
    override public func className() -> String {
        return "VectorTile.Tile"
    }
    //Meta information declaration end

    final public class Builder : ExtendableMessageBuilder {
      fileprivate var builderResult:VectorTile.Tile = VectorTile.Tile()
      public func getMessage() -> VectorTile.Tile {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var layers:Array<VectorTile.Tile.Layer> {
           get {
               return builderResult.layers
           }
           set (value) {
               builderResult.layers = value
           }
      }
      @discardableResult
      public func setLayers(_ value:Array<VectorTile.Tile.Layer>) -> VectorTile.Tile.Builder {
        self.layers = value
        return self
      }
      @discardableResult
      public func clearLayers() -> VectorTile.Tile.Builder {
        builderResult.layers.removeAll(keepingCapacity: false)
        return self
      }
      override public var internalGetResult:ExtendableMessage {
           get {
               return builderResult
           }
      }
      @discardableResult
      override public func clear() -> VectorTile.Tile.Builder {
        builderResult = VectorTile.Tile()
        return self
      }
      override public func clone() throws -> VectorTile.Tile.Builder {
        return try VectorTile.Tile.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> VectorTile.Tile {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> VectorTile.Tile {
        let returnMe:VectorTile.Tile = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:VectorTile.Tile) throws -> VectorTile.Tile.Builder {
        if other == VectorTile.Tile() {
         return self
        }
        if !other.layers.isEmpty  {
           builderResult.layers += other.layers
        }
        try mergeExtensionFields(other: other)
        try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> VectorTile.Tile.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> VectorTile.Tile.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 26:
            let subBuilder = VectorTile.Tile.Layer.Builder()
            try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
            layers.append(subBuilder.buildPartial())

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> VectorTile.Tile.Builder {
        let resultDecodedBuilder = VectorTile.Tile.Builder()
        if let jsonValueLayers = jsonMap["layers"] as? Array<Dictionary<String,Any>> {
          var jsonArrayLayers:Array<VectorTile.Tile.Layer> = []
          for oneValueLayers in jsonValueLayers {
            let messageFromStringLayers = try VectorTile.Tile.Layer.Builder.decodeToBuilder(jsonMap:oneValueLayers).build()

            jsonArrayLayers.append(messageFromStringLayers)
          }
          resultDecodedBuilder.layers = jsonArrayLayers
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> VectorTile.Tile.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try VectorTile.Tile.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

}
extension VectorTile.Tile: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<VectorTile.Tile> {
    var mergedArray = Array<VectorTile.Tile>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> VectorTile.Tile? {
    return try VectorTile.Tile.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> VectorTile.Tile {
    return try VectorTile.Tile.Builder().mergeFrom(data: data, extensionRegistry:VectorTile.VectorTileRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> VectorTile.Tile {
    return try VectorTile.Tile.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> VectorTile.Tile {
    return try VectorTile.Tile.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> VectorTile.Tile {
    return try VectorTile.Tile.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> VectorTile.Tile {
    return try VectorTile.Tile.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> VectorTile.Tile {
    return try VectorTile.Tile.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension VectorTile.Tile.Value: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<VectorTile.Tile.Value> {
    var mergedArray = Array<VectorTile.Tile.Value>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> VectorTile.Tile.Value? {
    return try VectorTile.Tile.Value.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> VectorTile.Tile.Value {
    return try VectorTile.Tile.Value.Builder().mergeFrom(data: data, extensionRegistry:VectorTile.VectorTileRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> VectorTile.Tile.Value {
    return try VectorTile.Tile.Value.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> VectorTile.Tile.Value {
    return try VectorTile.Tile.Value.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> VectorTile.Tile.Value {
    return try VectorTile.Tile.Value.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> VectorTile.Tile.Value {
    return try VectorTile.Tile.Value.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> VectorTile.Tile.Value {
    return try VectorTile.Tile.Value.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension VectorTile.Tile.Feature: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<VectorTile.Tile.Feature> {
    var mergedArray = Array<VectorTile.Tile.Feature>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> VectorTile.Tile.Feature? {
    return try VectorTile.Tile.Feature.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> VectorTile.Tile.Feature {
    return try VectorTile.Tile.Feature.Builder().mergeFrom(data: data, extensionRegistry:VectorTile.VectorTileRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> VectorTile.Tile.Feature {
    return try VectorTile.Tile.Feature.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> VectorTile.Tile.Feature {
    return try VectorTile.Tile.Feature.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> VectorTile.Tile.Feature {
    return try VectorTile.Tile.Feature.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> VectorTile.Tile.Feature {
    return try VectorTile.Tile.Feature.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> VectorTile.Tile.Feature {
    return try VectorTile.Tile.Feature.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension VectorTile.Tile.Layer: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<VectorTile.Tile.Layer> {
    var mergedArray = Array<VectorTile.Tile.Layer>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> VectorTile.Tile.Layer? {
    return try VectorTile.Tile.Layer.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> VectorTile.Tile.Layer {
    return try VectorTile.Tile.Layer.Builder().mergeFrom(data: data, extensionRegistry:VectorTile.VectorTileRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> VectorTile.Tile.Layer {
    return try VectorTile.Tile.Layer.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> VectorTile.Tile.Layer {
    return try VectorTile.Tile.Layer.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> VectorTile.Tile.Layer {
    return try VectorTile.Tile.Layer.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> VectorTile.Tile.Layer {
    return try VectorTile.Tile.Layer.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> VectorTile.Tile.Layer {
    return try VectorTile.Tile.Layer.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}

// @@protoc_insertion_point(global_scope)
